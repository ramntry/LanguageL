Реализация интерпретатора для языка L с нестрогой семантикой выражений и
операциями инкремента и декремента.


Модуль LanguageL.hs можно скомплировать и запустить как самостоятельное
приложение:

ghc -O2 LanguageL.hs
./LanguageL

Но им можно пользоваться и в интерактивном режиме с помощью GHCi:

ghci LanguageL.hs

<...>
Prelude Main>

Для краткости далее приглашение командной строки GHCi будем обозначать так:

>

Модуль позволяет:

1) Строить и красиво печатать выражения на языке L. Например:

-  Переменные:

> V "x"  -- V значит "Variable", в выражениях встречается очень часто,
x        -- потому имя сокращёно так сильно

> V "ho-ho"  -- Имена переменных - это произвольные строки
ho-ho

-  Целочисленные константы:

> C 10  -- C значит "Constant"
10

> C 91587018715093874107385108475014875109875108457
91587018715093874107385108475014875109875108457
  -- Это длинный целый тип, так что величина возможных
  -- значений ограничена только доступной памятью

-  Более сложные выражения, такие как инкремент и декремент:

> Inc "x"
x++

> Dec "y"
y--

Инкремент и декремент применимы только к переменным, произвольное
выражение модифицировать нельзя:

> Inc (Inc "err")

<interactive>:10:6:
    Couldn't match type `Expression' with `[Char]'
    Expected type: VarName
      Actual type: Expression
    In the return type of a call of `Inc'
    In the first argument of `Inc', namely `(Inc "err")'
    In the expression: Inc (Inc "err")

Если уже есть выражение-переменная, то можно не извлекать её имя вручную,
а воспользоваться вспомогательными функциями inc и dec:

> let x = V "x"
> dec x
x--

> let err = Inc "err"
> inc err
*** Exception: [Language L] Internal Error: Only variable can be incremented.

Ошибки с тегом "Internal Error" возникают при неправильном конструировании
выражений и программ на языке L, а также из-за ошибок реализации
интерпретатора. При возникновении ошибок в процессе вычисления семантики
выражений и программ на языке L ввиду возникновения неопределённых ситуаций
(вроде деления на ноль или чтения из пустого входного потока) сообщения
получают другие теги: "Expression Evaluation" и "Program Execution"
соответственно.


-  Бинарные операции, всего их 13: :+, :*, :-, :/, :%, :<, :>, :==, :!=,
:<=, :>=, :&&, :||

> C 2 :+ C 3
2 + 3

> V "x" :< V "y"  -- в текущем топике речь идёт о конструировании выражений
x < y             -- о их вычислении смотрите ниже

Ассоциативность и приоритеты бинарных операций друг относительно друга
имеют такие же значения, как и в Haskell. Если нужно сгруппировать
подвыражения другим способом, используйте скобки:

> C 1 :+ C 2 :+ C 3
1 + 2 + 3

> C 1 :+ (C 2 :+ C 3)
1 + (2 + 3)

> C 5 :* C 3 :+ C 4
5 * 3 + 4

> C 5 :* (C 3 :+ C 4)
5 * (3 + 4)


-  Можно конструировать выражения, которые при вычислении обязательно
приведут в неопределённое состояние:

> Inc "x" :/ C 0 :&& C 2
x++ / 0 && 2


2) Вычислять выражения при различных значениях переменных.

Семантический домен для выражений имеет следующий тип:

> :i Semantics
type Semantics = State -> (Integer, State)

Так как вычисление выражения может изменять значение переменных (с помощью
унарных операторов инкремента и декремента), семантика выражения является
функцией, вычисляющей по некоторому состоянию

значение выражения в этом состоянии и новое, возможно изменённое,
состояние. Ясно, что вычисление выражения не может расширить или сузить
область определения состояния (множество определённых переменных), но может
изменить значения переменных.

В модуле LanguageL определено пустое состяние:

> emptyState
[]

и ряд операций над состоянием. Добавить в состояние новое значение
некоторой переменной можно так:

> emptyState <-- "x" .= 10
[x = 10]

Ассоциативность и приоритеты операторов позволяют легко определять
значения сразу множества переменных:

> emptyState <-- "x" .= 10 <-- "y" .= 20 <-- "x" .= 0  -- более поздние
определения перезаписывают ранние
[x = 0, y = 20]

То же можно сделать с помощью оператора множественного определения
переменных (<==), так:

> emptyState <== ["x" .= 1, "y" .= 2, "z" .= 3]
[x = 1, y = 2, z = 3]

или так:

> emptyState <== [("x", 1), ("y", 2), ("z", 3)]
[x = 1, y = 2, z = 3]

Операторы (<--) и (<==) тоже можно смешивать:

> emptyState <== [("x", 1), ("y", 2)] <-- "z" .= 3 <== ["w" .= 4, "u" .= 5]
[u = 5, w = 4, x = 1, y = 2, z = 3]

Для удобства определена ещё одна функция-конструктор состояния:

> fromEnv [("x", 1), ("y", 2), ("z", 3)]
[x = 1, y = 2, z = 3]
  -- Env значит "Environment", обычно такое имя имеет
  -- значение типа [(VarName, Integer)]


Запросить значение переменной в состоянии можно с помощью оператора (.$):

> let s = fromEnv $ zip (map (: []) ['a'..'h']) [1..]
> s
[a = 1, b = 2, c = 3, d = 4, e = 5, f = 6, g = 7, h = 8]
> s.$ "a"
1
> s.$ "h"
8
> s.$ "x"
*** Exception: [Language L] Expression Evaluation: Variable `x' is not defined.


Вот так можно определить семантику выражения Inc "x":

> let x = "x"

> :t \s -> (s.$ x, s <-- x .= s.$ x + 1)
\s -> (s.$ x, s <-- x .= s.$ x + 1) :: State -> (Integer, State)


Вычислить сематику любого выражения можно с помощью функции sema:

> :t sema (Inc "a")
sema (Inc "a") :: Semantics

Затем семантику можно применить к какому-нибудь состоянию:

> sema (Inc "a") s
(1,[a = 2, b = 2, c = 3, d = 4, e = 5, f = 6, g = 7, h = 8])

> sema (V "a" :+ V "b") s
(3,[a = 1, b = 2, c = 3, d = 4, e = 5, f = 6, g = 7, h = 8])

> sema (V "a" :|| V "b") s
(1,[a = 1, b = 2, c = 3, d = 4, e = 5, f = 6, g = 7, h = 8])

> sema (V "a" :&& V "b") s
(*** Exception: [Language L] Expression Evaluation: Only 0 and 1 is allowed in a boolean position.

Как видно, семантика выражений нестрогая, в частности операторы конъюнкции
:&& и дизъюнкции :|| вычисляют свои аргументы только если они необходимы.
Также логические операторы требуют, чтобы логическое значение было равно 0
(ложь) или 1 (истина), другие значения приводят к неопределённому
состоянию. Таким образом, семантическая функция sema определена всюду, а
вот вычисляемое ею значение типа Semantics может быть применимо лишь к
части состояний (или может быть нигде неприменимо).

Так как вычисление выражений может изменять значение переменных, порядок
вычисления аргументов бинарных операторов важен. Выражения с бинарными
операторами вычисляются в соответствии с их приоритетами и
ассоциативностью, причём сначала вычисляется левый агрумент оператора,
затем правый:

> let e = Inc "x" :* Inc "x" :+ Dec "x" :+ Inc "x"
> sema e (emptyState <-- "x" .= 2)
(13,[x = 4])

> e
x++ * x++ + x-- + x++
> 2 *   3 +   4 +   3
13


Для удобства вычисления значений выражений определена ещё одна функция,
eval:

> :t eval
eval :: [(VarName, Integer)] -> Expression -> Integer

> eval [("x", 2)] (Inc "x" :* Inc "x" :+ Dec "x" :+ Inc "x")
13


3) Строить и красиво печатать программы на языке L.

В язык L входят операторы:

> Skip
skip

> "x" ::= V "y" :% C 2  -- оператор присваивания имеет вид (::=), в левой
x := y % 2              -- его части может находиться только переменная

> Read "x"  -- Прочесть из входного потока можно только переменную
read(x)

> Write (C 10 :+ C 20)
write(10 + 20)
            -- ... а записать в него значение произвольного выражения

> If (V "x" :< C 10) (Write (C 0)) (Write (C 1))
  -- три части условного оператора (условное выражение и два
  -- оператора), скорее всего, придётся обособлять скобками
if x < 10 then
  write(0)
else
  write(1)

> While (V "i" :!= C 0) ("x" ::= V "x" :* Dec "i")
  -- то же касается оператора цикла
while i != 0 do
  x := x * i--

Оператор следования (точка с запятой) имеет вид (:.), у него достаточно
низкий приоритет и правая ассоциативность, что позволяет опускать
существенную часть скобок:

> Read "a":. Read "b":. Write (V "a" :+ V "b")
read(a);
read(b);
write(a + b)


При некоторой сноровке можно записывать достаточно большие программы на
языке L, например:

- Программа вычисления факториала (определена в модуле LanguageL под
именем testProgram1):

> :{
| Read "n":.
| If (V "n" :< C 0) (
|   Write (C 0))
| (
|   "x" ::= C 1:.
|   "i" ::= C 0:.
|   While (Inc "i" :< V "n") (
|     "x" ::= V "x" :* V "i"):.
|   Write (V "x"))
| :}
read(n);
if n < 0 then
  write(0)
else
  x := 1;
  i := 0;
  while i++ < n do
    x := x * i;
  write(x)


- Программа вычисления наибольшего общего делителя (определена в модуле
LanguageL под именем testProgram2):

> :{
| Read "a":.
| Read "b":.
| While (V "b" :!= C 0 :&& V "a" :!= C 0) (
|   "a" ::= V "a" :% V "b":.
|   If (V "a" :!= C 0) (
|     "b" ::= V "b" :% V "a")
|   (
|     Skip)):.
| Write (V "a" :+ V "b")
| :}
read(a);
read(b);
while b != 0 && a != 0 do
  a := a % b;
  if a != 0 then
    b := b % a
  else
    skip;
write(a + b)


- Программа вычисления первых n чисел Фибоначчи (определена под именем
testProgram3):

> :{
| Read "n":.
| "curr" ::= C 1:.
| "next" ::= C 1:.
| While (Dec "n" :!= C 0) (
|   Write (V "curr"):.
|   "tmp" ::= V "next":.
|   "next" ::= V "curr" :+ V "next":.
|   "curr" ::= V "tmp")
| :}
read(n);
curr := 1;
next := 1;
while n-- != 0 do
  write(curr);
  tmp := next;
  next := curr + next;
  curr := tmp


4) Выполнять программы и анализировать их поведение.

Можно считать, что программа на языке L исполняется на некоторой
абстрактной машине, состояние которой полностью характеризуется
конфигурацией:

> :i Configuration
type Configuration = (State, Stream, Stream)

Stream - это поток целых чисел, входной и выходной (в таком порядке):

> :i Stream
type Stream = [Integer]

Выходной поток интерпретатор хранит в инвертированном виде (голова списка
[Integer] - последний записанный в выходной поток элемент).

Каждый оператор начинает исполнение в некоторой конфигурации и переводит
абстрактную машину в некоторую другую конфигурацию, возможно,
неопределённую. В последнем случае интерпретатор остановит работу и
сообщит об ошибке.


Начальная конфигурация зависит от содержимого входного потока:

> :t initialConf
initialConf :: Stream -> Configuration

> :t initialConf [1..]
initialConf [1..] :: Configuration
  -- Haskell позволяет проинициализировать входной поток бесконечной
  -- последовательностью целых чисел

> initialConf [1, 2]
([],[1,2],[])


В модуле LanguageL.hs семантика языка L описана двумя различными способами
- с большим шагом и малым шагом.
Интерпретатор большого шага имеет тип:

> :t bigStep
bigStep :: Statement -> Configuration -> Configuration

Он позволяет одномоментно выполнить программу:

> bigStep ("x" ::= C 1:. Write (C 42)) (emptyState <-- "haha" .= -1, [5], [])
([haha = -1, x = 1],[5],[42])

> bigStep testProgram1 (initialConf [])  -- Программа вычисления факториала
*** Exception: [Language L] Program Execution: Can not read from an empty input stream.

> bigStep testProgram1 (initialConf [4])
([i = 5, n = 4, x = 24],[],[24])


Семантика программы, однако, имеет другой тип:

> :t programSema
programSema :: Statement -> Stream -> Stream

> programSema testProgram2 [12, 21]
[3]
  -- Программа вычисления наибольшего общего делителя

Она также требует, чтобы выходной поток программы был пуст к моменту
завершения её работы:

> programSema ("x" ::= C 1:. Write (C 42)) [5]
*** Exception: [Language L] Program Execution: Program has completed with non-empty input stream.

Неопределён также выходной поток программы, пытающейся использовать
значение ранее неопределённой переменной. Потому, например, следующие две
программы не эквивалентны:

> programSema Skip []
[]

> programSema ("x" ::= V "x") []
*** Exception: [Language L] Expression Evaluation: Variable `x' is not defined.

Другой пример неопределённого результата работы программы - попытка
использовать в качестве условного выражения выражение, значение которого
отлично от 0 или 1:

> programSema (Read "x":. If (Dec "x") Skip Skip) [2]
*** Exception: [Language L] Program Execution: Only 0 and 1 is allowed in a boolean position.

Видно, что сообщение в таком случае имеет тег "Program Execution", это
верно, так как ошибки в вычислении выражения (Dec "x") здесь нет. Иначе
обстоит дело в таком примере:

> programSema (Read "x":. If (Dec "x" :|| C 1) Skip Skip) [2]
*** Exception: [Language L] Expression Evaluation: Only 0 and 1 is allowed in a boolean position.


programSema для удобства инвертирует выходной поток, порождаемый
программой на языке L, приводя его таким образом в нормальный порядок:

> programSema testProgram3 [10]
[1,1,2,3,5,8,13,21,34,55]
  -- Программа вычисления последовательности Фибоначчи

Другие функции этого инвертирования не делают.



smallStep интерпретатор позволяет выполнять программу пошагово:

> :t smallStep
smallStep :: Statement -> Configuration -> SmallStepResult

> :i SmallStepResult
data SmallStepResult
  = Completed Configuration | Uncompleted Configuration Statement

Шаг может перевести программу в завершённое состояние
(Completed Configuration), а может сконструировать вместе с новой
конфигурацией остаточное вычисление (Uncompleted Configuration Statement):

> smallStep (Write (C 0)) (initialConf [])
([],[],[0]) ==|

> smallStep (Write (C 0):. Write (C 1):. Write (C 2)) (initialConf [])
([],[],[0]) =>>
write(1);
write(2)

Для удобства в модуле LanguageL определена функция step, которая позволяет
выполнить ещё один шаг из результирующего состояния после предыдущего:

> :t step
step :: SmallStepResult -> SmallStepResult

а также функция-конструктор начального состояния такого вычисления:

> :t step0
step0 :: Statement -> Stream -> SmallStepResult

> step0 testProgram1 [2]
  -- для этой программы не было выполнено ещё ни одного шага
([],[2],[]) =>>
read(n);
if n < 0 then
  write(0)
else
  x := 1;
  i := 0;
  while i++ < n do
    x := x * i;
  write(x)


С помощью оператора (|>) можно последовательно выполнять шаги выполнения
программы:

> step0 testProgram1 [2] |> step
([n = 2],[],[]) =>>
if n < 0 then
  write(0)
else
  x := 1;
  i := 0;
  while i++ < n do
    x := x * i;
  write(x)

> step0 testProgram1 [2] |> step |> step
([n = 2],[],[]) =>>
x := 1;
i := 0;
while i++ < n do
  x := x * i;
write(x)

> step0 testProgram1 [2] |> step |> step |> step
([n = 2, x = 1],[],[]) =>>
i := 0;
while i++ < n do
  x := x * i;
write(x)


а с помощью функции stepByStep вывести полную пошаговую историю выполнения
программы:

> :t stepByStep
stepByStep :: Statement -> Stream -> ExecutionHistory

> :i ExecutionHistory
data ExecutionHistory
  = ExecutionHistory [SmallStepResult] SmallStepResult

> stepByStep (Read "a":. "b" ::= V "a":. Read "a":. Write (V "a" :+ V "b")) [10, 20]
0: ([],[10,20],[]) =>>
read(a);
b := a;
read(a);
write(a + b)

1: ([a = 10],[20],[]) =>>
b := a;
read(a);
write(a + b)

2: ([a = 10, b = 10],[20],[]) =>>
read(a);
write(a + b)

3: ([a = 20, b = 10],[],[]) =>>
write(a + b)

4: ([a = 20, b = 10],[],[30]) ==|


Возможно также вместо вывода на печать использовать ExecutionHistory
как-нибудь иначе, например, извлечь из неё завершённую конфигурацию
исполнения программы:


> configurationOfHistory (stepByStep testProgram3 [10])
([curr = 89, n = -1, next = 144, tmp = 89],[],[55,34,21,13,8,5,3,2,1,1])



Enjoy it! :)
